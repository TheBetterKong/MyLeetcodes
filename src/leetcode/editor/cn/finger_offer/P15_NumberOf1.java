/******************************* Java：二进制中1的个数 *******************************/
// 请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。
// 例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。
//
// 
//
// 示例 1： 
//
// 输入：00000000000000000000000000001011
// 输出：3
// 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
// 
//
// 示例 2： 
//
// 输入：00000000000000000000000010000000
// 输出：1
// 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
// 
//
// 示例 3： 
//
// 输入：11111111111111111111111111111101
// 输出：31
// 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
//
// 
//
// 提示： 
//
// 输入必须是长度为 32 的 二进制串 。 
// 
//
// 注意：本题与主站 191 题相同：https://leetcode-cn.com/problems/number-of-1-bits/ 
// Related Topics 位运算 
// 👍 149 👎 0


/******************************* 题目思路 *******************************/
// 我们都知道，求一个正整数二进制中 1 的个数很简单，只需要不断除 2，余 1 时，count+1 就可以了。
// 但是本题主要难点就在于输入的整数可能为负，而负数在计算机中采用补码表示，其 1 的个数计算起来就比较麻烦，
// 咋眼一看，很让人没有头绪。
//
// 上面说到的，正整数处理方法的核心就在于移位：
//      1. 而负数的补码在右移时，最高位填 1，这就会影响我们计算 1 的结果。
//              当然了，你也可以说我把移位的次数保留下来最后再减掉就好了，这种思路我也尝试过，
//              真正实现起来比较复杂，有兴趣可以再试一下。
//      2. 既然补码右移麻烦，那就考虑左移。在最高上与 1 计数，然后不断左移。
//              我们知道，一个 int 类型的变量在计算机里是 32 位，那么最高位为 1 的数应该就是：-2^31，
//              这个数具体是多少，我是不会算了，真要实现就得调 math 里的 pow 方法，所以，我还是把这个思路放弃了。
//
// 好了，两种处理数的办法都行不通，看来对数本身进行处理是不太可能了，那就另辟蹊径，把用来进行与操作的 flag 进行移位：
//      ① 初始时，flag = 1（二进制表示：0000 0000 0000 0000 0000 0000 0000 0001）；
//      ② n & flag，就能知道 n 最低位是否为 1；
//      ③ flag 左移 1 位，flag=flag<<1（二进制表示：0000 0000 0000 0000 0000 0000 0000 0010），再 n & flag，就能知道 n 倒数第二位是否为 1；
//      ④ 循环下去，直至 flag 32 次左移后，1 溢出，flag = 0；
//      ⑤ 注意：n & flag 是否需要 count++ 的判别标准是 (n & flag)!=0，原因仔细琢磨一下就知道了。
//
// 另外，我们还可以再进一部做位优化：
//      n & (n−1)，其预算结果恰为把 n 的二进制位中的最低位的 1 变为 0 之后的结果。
//      这样我们可以利用这个位运算的性质加速我们的检查过程，在实际代码中，我们不断让当前的 n 与 n−1 做与运算，直到 n 变为 0 即可。
//      因为每次运算会使得 n 的最低位的 1 被翻转，因此运算次数就等于 n 的二进制位中 1 的个数。
// 该思路在 P191 里实现

/******************************* 题目代码 *******************************/
package leetcode.editor.cn.finger_offer;

class P15_NumberOf1 {
    public static void main(String[] args) {
        Solution solution = new P15_NumberOf1().new Solution();
        // TO TEST
        int n = 9;
        int answer = solution.hammingWeight(n);
        System.out.println(answer);
    }

    //leetcode submit region begin(Prohibit modification and deletion)
    public class Solution {
        // you need to treat n as an unsigned value
        public int hammingWeight(int n) {
            int flag = 1;
            int count = 0;
            while (flag != 0) {
                if ((n & flag) != 0) {
                    count++;
                }
                flag = flag << 1;
            }
            return count;
        }
    }
    //leetcode submit region end(Prohibit modification and deletion)

}

/******************************* 代码评价 *******************************/
// 时间复杂度：O(k)，k 为 int 类型二进制数的长度
// 空间复杂度：O(1)