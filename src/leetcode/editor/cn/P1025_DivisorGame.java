/******************************* Java：除数博弈 *******************************/
// 爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。
//
// 最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作： 
//
// 
// 选出任一 x，满足 0 < x < N 且 N % x == 0 。 
// 用 N - x 替换黑板上的数字 N 。 
// 
//
// 如果玩家无法执行这些操作，就会输掉游戏。 
//
// 只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 False。假设两个玩家都以最佳状态参与游戏。 
//
// 
//
// 
// 
//
// 示例 1： 
//
// 输入：2
// 输出：true
// 解释：爱丽丝选择 1，鲍勃无法进行操作。
// 
//
// 示例 2： 
//
// 输入：3
// 输出：false
// 解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。
// 
//
// 
//
// 提示： 
//
// 
// 1 <= N <= 1000 
// 
// Related Topics 数学 动态规划 
// 👍 263 👎 0


/******************************* 题目思路 *******************************/
// 拿到这个题目的时候，一开始，哇！这啥意思，我该怎么办？
// 然后拿出来笔纸模拟一下，从 1 开始，尝试了几个数，发现好像 “N 为奇数的时候 Alice（先手）必败，N 为偶数的时候 Alice 必胜”？
// 然后一行代码写上，通过了？。。。。。。。。好吧。很懵。看来找规律有时候也是个很好的办法。
//
// 本着学习的精神，参看官方解答，按照动态规划应该怎么办呢？
//      这里，假想出一个 状态：f[i] 表示当前数字 i 的时候先手是处于必胜态还是必败态，true 表示先手必胜，false 表示先手必败；
//      从前往后递推，根据我们上文的分析，枚举 i 在 (0,i) 中 i 的因数 j，看是否存在 f[i−j] 为必败态即可。
//

/******************************* 题目代码 *******************************/
package leetcode.editor.cn;

class P1025_DivisorGame {
    public static void main(String[] args) {
        Solution solution = new P1025_DivisorGame().new Solution();
        // TO TEST
        int N = 9;
        boolean answer = solution.divisorGame(N);
        System.out.println(answer);
    }

    //leetcode submit region begin(Prohibit modification and deletion)
    class Solution {
        public boolean divisorGame(int N) {
            boolean[] f = new boolean[N + 5];
            f[1] = false;
            f[2] = true;

            // 开始一项一项的枚举是否存在，先手方选完某个数字后，让后手方处于一种必败的局面
            for (int i = 3; i <= N; ++i) {
                // 先手方选完，开始迭代后手方的选择情况
                for (int j = 1; j < i; ++j) {
                    if ((i % j) == 0 && !f[i - j]) {    // 左边是为了保证，后手方选的要是约数；右边表示选取的这个约数，后手方必败；
                        f[i] = true;
                        break; // 只要有这种局面(先手方选完数后，可以让后手方必败），就不用在考虑了，先手方必胜
                    }
                }
            }
            return f[N];
        }
    }
    //leetcode submit region end(Prohibit modification and deletion)

}

/******************************* 代码评价 *******************************/
// 时间复杂度 O(n^2)
// 空间复杂度 O(n)
// 所以可以看出，有时候，合理运用算法，找规律，简单问题，对算法效率的提高大有益处