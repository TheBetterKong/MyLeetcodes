/******************************* Java：下一个排列 *******************************/
// 实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
//
// 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 
//
// 必须 原地 修改，只允许使用额外常数空间。 
//
//
// 示例 1： 
//
// 输入：nums = [1,2,3]
// 输出：[1,3,2]
// 
//
// 示例 2： 
//
// 输入：nums = [3,2,1]
// 输出：[1,2,3]
// 
//
// 示例 3： 
//
// 输入：nums = [1,1,5]
// 输出：[1,5,1]
// 
//
// 示例 4： 
//
// 输入：nums = [1]
// 输出：[1]
// 
//
// 
//
// 提示： 
//
// 1 <= nums.length <= 100 
// 0 <= nums[i] <= 100 
// 
// Related Topics 数组 
// 👍 1104 👎 0


/******************************* 题目思路 *******************************/
// 看到题目，只允许我们原地修改，那就说明本题是一个直接操作数组的题，而数组里最常用的思想，无非就是 “遍历” “双指针”；
// 接下来，问题就是，如何遍历？找规律，找特性！
// 找字典序的下一个排列，即所谓的下一个更大的数，我们以序列：1,5,8,5,1,3,4,6,7 为例来分析。
// 最自然而然的想法就是，分析元素间的大小关系，突破点也是在此。
//
// 首先，我们按照以往最常用的办法：找最大值，最小值。这时候你会发现，想要求解下一个更大，不仅和最值有关，还与元素的位置关系有关。
// 这时候，另一种分析办法就来了：找逆序对！
//
// 接着，你是不是也会遇到一个问题：分析过程中，总感觉没有规章，思路很乱，绕着绕着就把自己绕糊涂了。那简单，我们从特殊情况入手：
// “没有下一个更大元素时，把问题变为：它的上一个排列是什么？”
// （1）把上面的排列排成最小，即：1,1,3,4,5,5,6,7,8，找它的下一个排列是什么，你会怎么找？
//       此时，排列主要关注的数字就是最后两个：7，8；
//       从后往前找，把 7 和 8 两个数交换；
// （2）问题难度加大，在上面的排列的基础上（即：1,1,3,4,5,5,6,8,7），再找它的下一个排列是什么，你会怎么找？
//       此时，排列主要关注的数字就是最后三个：6,8,7；
//       比 687 大的下一个数，也就是 768；（注意留意，你的潜意识里是怎么算出来 768 的！！！）
// （3）继续，再在上一个的基础上（即：1,1,3,4,5,5,7,6,8），再找它的下一个排列是什么，你会怎么找？
//       此时，排列主要关注的数字又变成了最后两个：6,8；
//       比 68 大的下一个数，也就是 86；
// （4）再继续，再在上一个的基础上（即：1,1,3,4,5,5,7,8,6），再找它的下一个排列是什么，你会怎么找？
//       此时，排列主要关注的数字又变成了最后三个：7,8,6；
//       比 786 大的下一个数，也就是 867；
// ......
// 相信到这里，你已经基本掌握到规律了，如果还没有，那就继续展开分析。做一下总结：
//  ① 找我们需要关注的元素：
//          从后往前遍历，如果发现 a[i-1] < a[i]，那么从 i-1 从数列末尾的元素都是我们需要关注的，注意相等不算。
//  ② 在这些关注的元素里（a[i-1] 到 a[n]），找下一个更大数：
//          注意一个规律：先不看 a[i-1]，此时 a[i,n] 是从大到小排列的，
//          那么从 a[n] 往 a[i] 反向遍历，找第一个比 a[i-1] 大的元素 a[j]，交换 a[i-1] 和 a[j]；
//          此时 a[i-1] 位置的元素确定完毕，a[i,n] 依旧呈降序；
//          最后一步：反转 a[i,n]，使之呈升序，即最小排列

/******************************* 题目代码 *******************************/
package leetcode.editor.cn;

import java.util.Arrays;

class P31_NextPermutation {
    public static void main(String[] args) {
        Solution solution = new P31_NextPermutation().new Solution();
        // TO TEST
        int[] nums = {3,2,1};
        solution.nextPermutation(nums);
        System.out.println(Arrays.toString(nums));
    }

    //leetcode submit region begin(Prohibit modification and deletion)
    class Solution {
        public void nextPermutation(int[] nums) {
            int i = nums.length - 1;
            // 确定需要关注的数列起始位置
            while(i > 0 && nums[i-1] >= nums[i]) {
                i--;
            }
            if (i > 0) {
                int j = nums.length - 1;
                while (j > i-1 && nums[i-1] >= nums[j]) {
                    j--;
                }
                swap(nums, i-1, j);
            }
            reverse(nums, i);
        }

        private void swap(int[] nums, int i, int j) {
            int temp = nums[j];
            nums[j] = nums[i];
            nums[i] = temp;
        }

        private void reverse(int[] nums, int i) {
            int begin = i, end = nums.length - 1;
            while (begin < end) {
                swap(nums, begin, end);
                begin++;
                end--;
            }
        }
    }
    //leetcode submit region end(Prohibit modification and deletion)

}

/******************************* 代码评价 *******************************/
// 时间复杂度：O(n)，线性级别的复杂度，主要开销在于两次扫描，一次反转
// 空间复杂度：O(1)